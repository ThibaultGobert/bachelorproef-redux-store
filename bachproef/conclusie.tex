%%=============================================================================
%% Conclusie
%%=============================================================================

\chapter{Conclusie}
\label{ch:conclusie}

%% TODO: Trek een duidelijke conclusie, in de vorm van een antwoord op de
%% onderzoeksvra(a)g(en). Wat was jouw bijdrage aan het onderzoeksdomein en
%% hoe biedt dit meerwaarde aan het vakgebied/doelgroep? Reflecteer kritisch
%% over het resultaat. Had je deze uitkomst verwacht? Zijn er zaken die nog
%% niet duidelijk zijn? Heeft het onderzoek geleid tot nieuwe vragen die
%% uitnodigen tot verder onderzoek?

\section{Inleiding}
Redux is een framework die nog maar 3 jaar bestaat. Er is wel al veel documentatie beschikbaar en veel problemen zijn reeds ontdekt en opgelost, maar zeker niet alles staat beschreven. 

Bijvoorbeeld hoe 2 React-Redux projecten met elkaar kunnen interageren staat nergens beschreven. Omdat hier geen best practices vermeld werden, is de keuze gemaakt om via npm packages te werken. Op deze manier kan het ene project snel geïntegreerd worden in het andere. 

Het was echter niet voldoende om deze package gewoon te installeren. Wanneer dan een component werd aangeropen zou de state niet volledig zijn. De state bevat dan enkel objecten van het hoofdproject en niet van het geïntegreerde project. Om deze reden moeten de reducers geëxporteerd worden uit het geïntegreerde project. 

\section{Performantie}
Zoals eerder vermeld was de oplossing om deze reducers in een object te steken en dit te exporteren. Het grootste probleem hierbij is dat veranderingen in het project dat geïntegreerd moet worden grote gevolgen kan hebben. Dit werd ondervonden door het open source project van Scratch. Na een update van Scratch uit en de bijhorende update om de package up to date te houden werkte deze niet meer. Dit kwam door een verandering in de structuur van de reducers, waardoor het niet meer de juiste reducers waren die geëxporteerd werden. Dit zorgt er dus voor dat er zeer aandachtig moet gebleven worden bij updates. Om deze reden zou er nood zijn aan een methode uncombineReducers of een alternatief waardoor er enkel met de root reducer rekening zou gehouden moeten worden. Dan zouden externe updates geen grote impact meer hebben en kan deze snel terug geïntegreerd worden.

Deze methode is niet optimaal, aangezien er heel wat onderhoudswerk bij komt kijken om de package up to date te houden. Een bijkomend probleem is dat met deze methode ook alle dependencies moeten overgenomen worden alsook de webpack configuraties. 

Deze methode wordt al een heel stuk performanter door het te integreren project te combineren in webpack, op deze manier is het niet meer nodig om alle dependencies toe te voegen aan het hoofdproject en wordt de package voor de webpack configuraties overbodig. 

Zoals eerder gezegd is deze methode afhankelijk van de veranderingen in het te integreren project. Als hier quasi geen veranderingen in moeten gebeuren zal dit geen grote impact hebben, als er constant veranderingen in gebeuren dan zal deze methode niet meer optimaal zijn. 

\section{Complexiteit}
Er zijn een aantal objectieve maatstaven die ontwikkeld zijn voor de complexiteit van software te meten. In grote lijnen kan men deze maatstaven verdelen in maten voor complexiteit die zijn gerelateerd aan de omvang van een software-programma, en in maten voor complexiteit die zijn gerelateerd aan de structuur van zo'n programma. De simpelste maat voor de omvang is het aantal regels programmacode: hoe meer regels, hoe groter de complexiteit. Een ernstig nadeel van deze simpele metriek is dat men het verschil in uitdrukkingskracht van de verschillende programmeertalen volledig verwaarloost.

Men maakt ook geen onderscheid naar soorten regels code. Er zijn echter eenvoudige regels code en er zijn complex samengestelde regels programmacode. Om hieraan tegemoet te komen, heeft Halstead een meer verfijnde metriek ontwikkeld. In zijn theorie is de complexiteit en de daarmee samenhangende programmeerinspanning afhankelijk van de omvang van een programma en van het niveau van structurering. Hoe groter de omvang, hoe hoger de programmeerinspanning. hoe hoger (compacter) het niveau van structurering, hoe lager de inspanning. Zowel omvang als niveau van structurering zijn functies van het aantal verschillende operatoren en operanden in een programma.
\autocite{complexiteit01}

Men kan nu deze metriek toepassen op het voorbeeld met de gemaakte package in deze studie. n1 staat voor het aantal verschillende operatoren, n2 staat voor het verschillende aantal operanden, N1 is het aantal operatoren en N2 is het aantal operanden. Met deze nummers kunnen een aantal metingen berekend worden:
\begin{itemize}
	\item Vocabulair van het programma: n = $n_1$ + $n_2$ = 3 + 23 = 27.
	\item Lengte van het programma: N = $N_1$ + $N_2$ = 27 + 43 = 70.
	\item Berekende lengte van het programma: $N_3$ = $n_1$ $log_{2}(n_1)$ + $n_2$ $log_{2}(n_2)$ = 4,7549 +  104,0419 = 108,7968.
	\item Volume: V = N * $log_{2}(n)$ = 70 * 4,7549 = 332,8422.
	\item Moeilijkheid: D = ($n_1$/2) * ($N_2/n_2$) = 1,5 * 1,8696 = 2,8043.
	\item Moeite: E = D * V = 2,8043 * 332,8422 = 933,3894.
\end{itemize}
De moeite meeteenheid kan vertaald worden naar codeertijd aan de hand van de volgende relatie: de tijd T = E/18 = 51,8550 seconden.
Halstead kan ook een schatting geven van het aantal errors die in de implementatie zitten door naar het aantal geleverde bugs te kijken: B = E\textsuperscript{2/3}/3000 = 0,1245.

Deze metriek werd toegepast op het exporteren van de reducers in de gepubliceerde package en de code die nodig is om alle reducers opnieuw te importeren in een hoofdproject. Er kan geconcludeerd worden dat het een snelle codeertijd heeft dat gepaard gaat met een laag aantal geleverde bugs.

 





\section{Eindconclusie}
Dit onderzoek is nog niet klaar, de basis is wel gelegd om verder onderzoek te doen naar een methode om de root reducers van beide projecten met elkaar te combineren zonder dat daar veel extra onderhoud aan te pas komt. Als uitkomst was wel verwacht dat er een soort uncombineReducers zou gemaakt worden, helaas was dit niet mogelijk door de implementatie van deze functie. Er is wel een alternatief gevonden om toch het probleem op te lossen. 

Achteraf gezien bleek het een goede keuze om voor het Scratch open source project te kiezen. Dit is een project dat nog steeds in development is en dat nu overschakelt op JavaScript, waardoor het zeer interessant wordt om dit te kunnen integreren in een eigen applicatie.   

Dit is een belangrijk onderzoek omdat er nog geen soortgelijke onderzoeken zijn gedaan of gedocumenteerd werden.
Er zijn een aantal statistieken gevonden die duidelijk maken dat het een probleemstelling is die uitnodigt tot verder onderzoek. De npm package die de reducer exports verzorgde is opgericht eind februari. Dan werd gezocht naar hoe het mogelijk wordt om dit project snel integreerbaar te maken, waar tot een tijdelijke oplossing is gekomen begin maart. Deze package werd sinds dan ruim 7000 keer gedownload (figuur 9) met piekmomenten van 2168 downloads per week (figuur 8) en 946 downloads per dag (figuur 7) in maart. Door tijdsgebrek was het echter onmogelijk om deze package constant up to date te houden. Eind maart kan er nog een update gezien worden door het stijgende aantal downloads, wat duidt op het feit dat er wel vraag naar is.